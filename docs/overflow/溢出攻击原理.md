# Truebit溢出攻击原理

## 什么是溢出?

想象一个汽车里程表,最大显示999999:
```
999999 + 1 = 000000  (回到0重新开始)
```

uint256也一样,最大值是 `2^256 - 1`,超过就回绕到0:
```
uint256最大值 = 2^256 - 1 ≈ 1.15 × 10^77

当计算结果 = 2^256 时:
2^256 mod 2^256 = 0  (溢出回绕为0!)
```

## 关键数学: 为什么选择 2^128?

```
(2^128)^2 = 2^256 = 0 (溢出后)

所以当 amount = 2^128 时:
amount * amount = 0
```

## 攻击流程图

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           正常用户 vs 攻击者                                  │
└─────────────────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────┐    ┌─────────────────────────────────────┐
│         正常用户铸造              │    │            攻击者铸造                 │
│      amount = 1000 代币          │    │      amount = 2^128 代币             │
└───────────────┬─────────────────┘    └─────────────────┬───────────────────┘
                │                                        │
                ▼                                        ▼
┌─────────────────────────────────┐    ┌─────────────────────────────────────┐
│  计算: 100 * amount^2 * reserve │    │  计算: 100 * amount^2 * reserve     │
│  = 100 * 1000^2 * 1000 ETH      │    │  = 100 * (2^128)^2 * 1000 ETH       │
│  = 100,000,000,000 (正常值)      │    │  = 100 * 2^256 * 1000 ETH           │
└───────────────┬─────────────────┘    └─────────────────┬───────────────────┘
                │                                        │
                │                                        ▼
                │                      ┌─────────────────────────────────────┐
                │                      │  uint256 最大值: 2^256 - 1          │
                │                      │  2^256 mod 2^256 = 0  ← 溢出回绕!   │
                │                      │  结果: 0                            │
                │                      └─────────────────┬───────────────────┘
                │                                        │
                ▼                                        ▼
┌─────────────────────────────────┐    ┌─────────────────────────────────────┐
│  cost = numerator / 1e36        │    │  cost = 0 / 1e36                    │
│  = 100,000,000,000 / 1e36       │    │  = 0                                │
│  = 正常成本                      │    │  = 零成本!                          │
└───────────────┬─────────────────┘    └─────────────────┬───────────────────┘
                │                                        │
                ▼                                        ▼
┌─────────────────────────────────┐    ┌─────────────────────────────────────┐
│  支付正常费用                    │    │  支付 0 ETH                         │
│  获得 1000 代币                  │    │  获得 2^128 代币 (天文数字!)         │
└─────────────────────────────────┘    └─────────────────────────────────────┘
```

## 溢出原理详解

```
uint256 的范围: 0 ~ 2^256-1

当计算结果 >= 2^256 时发生溢出回绕:

    实际值                    存储值 (mod 2^256)
    ─────────────────────    ─────────────────────
    2^256                 →  0
    2^256 + 1             →  1
    2^256 + 100           →  100
    2^257                 →  0
    3 * 2^256             →  0

关键: (2^128)^2 = 2^256 = 0 (mod 2^256)
```

## 攻击数学推导 (分步计算)

公式: `cost = (100 * amount^2 * reserve) / 1e36`

其中 `1e36 = 10^36` 是精度因子(1后面36个0)

### 正常用户 (amount = 1000)

```
step1: amount * amount     = 1000 * 1000           = 1,000,000
step2: 100 * step1         = 100 * 1,000,000       = 100,000,000
step3: step2 * reserve     = 100,000,000 * 10^21   = 10^29
step4: step3 / 1e36        = 10^29 / 10^36         = 0 (整数除法截断)

结果: 成本 = 0, 获得 1000 代币
```

### 攻击者 (amount = 2^128)

```
step1: amount * amount     = 2^128 * 2^128 = 2^256 = 0  ← 溢出!
step2: 100 * step1         = 100 * 0               = 0
step3: step2 * reserve     = 0 * 10^21             = 0
step4: step3 / 1e36        = 0 / 10^36             = 0

结果: 成本 = 0, 获得 2^128 代币 (天文数字!)
```

### 对比

| 用户   | amount | 成本 | 获得代币 |
|--------|--------|------|----------|
| 正常   | 1000   | 0    | 1000     |
| 攻击者 | 2^128  | 0    | 340282366920938463463374607431768211456 |

攻击者用相同成本获得了 `3.4 × 10^38` 倍的代币!

## 为什么SafeDiv无法防御?

```
┌─────────────────────────────────────────────────────────────┐
│                      计算流程                                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   step1: term1 = 100 * amount * amount * reserve            │
│                  ↑                                          │
│                  溢出发生在这里! (乘法)                       │
│                  term1 已经是错误的值 (0)                    │
│                                                             │
│   step2: numerator = term1 + term2                          │
│                      ↑                                      │
│                      加法操作正常的错误值                     │
│                                                             │
│   step3: cost = SafeDiv(numerator, 1e36)                    │
│                 ↑                                           │
│                 SafeDiv 只检查除数不为0                      │
│                 无法修复已经溢出的 numerator!                │
│                                                             │
└─────────────────────────────────────────────────────────────┘

SafeMath 覆盖情况:
┌──────────┬─────────────┬─────────────────────────────────┐
│  运算    │  是否保护    │  说明                           │
├──────────┼─────────────┼─────────────────────────────────┤
│  SafeAdd │  ✓          │  检查加法溢出                    │
│  SafeSub │  ✓          │  检查减法下溢                    │
│  SafeMul │  ✓          │  检查乘法溢出                    │
│  SafeDiv │  ✓          │  只检查除数不为0                 │
├──────────┼─────────────┼─────────────────────────────────┤
│  普通 *  │  ✗          │  Truebit漏洞! 未使用SafeMul     │
│  普通 +  │  ✗          │  Truebit漏洞! 未使用SafeAdd     │
└──────────┴─────────────┴─────────────────────────────────┘
```

## 攻击完整流程

```
┌─────────────────────────────────────────────────────────────┐
│  1. 攻击者分析合约                                           │
│     - 发现使用旧版Solidity (<0.8.0)                         │
│     - 发现只用了部分SafeMath (SafeDiv/SafeSub)              │
│     - 发现乘法未保护                                        │
└───────────────────────────┬─────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  2. 计算最佳攻击参数                                         │
│     - 寻找使 amount^2 溢出为0或极小值的 amount              │
│     - 2^128 是完美值: (2^128)^2 = 2^256 = 0                │
└───────────────────────────┬─────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  3. 执行攻击                                                │
│     - 调用 mint(2^128)                                      │
│     - 合约计算 cost = 0                                     │
│     - 攻击者支付 0 ETH                                      │
│     - 获得 2^128 代币                                       │
└───────────────────────────┬─────────────────────────────────┘
                            ▼
┌─────────────────────────────────────────────────────────────┐
│  4. 套现                                                    │
│     - 在DEX卖出代币                                         │
│     - 或调用withdraw抽干储备金                              │
│     - 损失: 2600万美元                                      │
└─────────────────────────────────────────────────────────────┘
```

## 防御方案

```
方案1: 使用 Solidity 0.8+ (推荐)
┌─────────────────────────────────────────────────────────────┐
│  pragma solidity ^0.8.0;                                    │
│                                                             │
│  // 0.8+ 默认检查所有算术运算                                │
│  // 溢出时自动 revert                                       │
│  uint256 result = 100 * amount * amount; // 溢出会revert   │
└─────────────────────────────────────────────────────────────┘

方案2: 完整使用 SafeMath
┌─────────────────────────────────────────────────────────────┐
│  using SafeMath for uint256;                                │
│                                                             │
│  // 所有运算都用SafeMath                                    │
│  uint256 term1 = uint256(100)                               │
│      .mul(amount)                                           │
│      .mul(amount)                                           │
│      .mul(reserve);                                         │
└─────────────────────────────────────────────────────────────┘

方案3: 输入验证
┌─────────────────────────────────────────────────────────────┐
│  function mint(uint256 amount) external {                   │
│      // 限制最大铸造量                                       │
│      require(amount <= MAX_MINT, "amount too large");       │
│      // 确保amount^2不会溢出                                │
│      require(amount <= type(uint128).max, "overflow risk"); │
│  }                                                          │
└─────────────────────────────────────────────────────────────┘
```

## 测试验证

### 查看分步计算过程 (推荐先运行这个)

```bash
forge test --match-test test_Step3 -vvv --offline
```

输出:
```
=== 第3步: 成本计算公式 ===
公式: cost = (100 * amount^2 * reserve) / 1e36

--- 正常用户: amount = 1000 ---
step1: amount * amount =
1000000
step2: 100 * step1 =
100000000
step3: step2 * reserve =
100000000000000000000000000000
最终成本: step3 / 1e36 =
0

--- 攻击者: amount = 2^128 ---
step1: amount * amount = (溢出!)
0
step2: 100 * step1 =
0
step3: step2 * reserve =
0
最终成本: step3 / 1e36 =
0

=== 结论 ===
正常用户铸造 1000 代币, 成本:
0
攻击者铸造 2^128 代币, 成本:
0
攻击者获得代币数量:
340282366920938463463374607431768211456
```

### 查看所有详解测试

```bash
forge test --match-contract OverflowExplainTest -vvv --offline
```

包含4个测试:
- `test_Step1_Uint256Max` - 理解uint256范围
- `test_Step2_OverflowMath` - 2^128平方如何溢出
- `test_Step3_CostCalculation` - 完整成本计算对比
- `test_Step4_SimpleOverflowDemo` - 用uint8简化演示溢出

### 查看攻击测试

```bash
forge test --match-contract OverflowAttackTest -vvv --offline
```

输出:
```
正常结果 (1000e18 代币): 100000000000000000000000000000000000000000000000000000000000000000
溢出结果 (2^128 代币): 0
攻击者获得代币: 340282366920938463463374607431768211456
攻击者支付 (仅term1): 0
```

## 相关文件

| 文件 | 说明 |
|------|------|
| `src/overflow/VulnerableBondingCurve.sol` | 漏洞合约 (Solidity 0.7.6) |
| `src/overflow/SafeBondingCurve.sol` | 安全版本 (Solidity 0.8+) |
| `test/overflow/OverflowExplain.t.sol` | 分步详解测试 |
| `test/overflow/OverflowAttack.t.sol` | 攻击演示测试 |
