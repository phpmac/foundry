# 算术漏洞类

## 1. 精度损失

**风险等级**: 中危

**漏洞逻辑**: 先除后乘导致精度丢失,累积后造成资金损失。

```solidity
contract VulnerablePrecision {
    function calculateReward(uint256 amount, uint256 rate) public pure returns (uint256) {
        return amount / 1000 * rate; // 错误: 先除后乘
    }

    function calculateRewardFixed(uint256 amount, uint256 rate) public pure returns (uint256) {
        return amount * rate / 1000; // 正确: 先乘后除
    }
}
```

**检测方法**: 检查除法运算顺序,使用边界值测试

---

## 2. unchecked溢出

**风险等级**: 中危

**漏洞逻辑**: unchecked块内运算可能溢出/下溢。

```solidity
contract VulnerableUnchecked {
    function unsafeDecrement(uint256 x) public pure returns (uint256) {
        unchecked {
            return x - 1; // x=0时下溢为type(uint256).max
        }
    }
}
```

**检测方法**: 搜索 `unchecked` 块,验证边界条件

---

## 3. 溢出回绕 + 精度丢失组合攻击

**风险等级**: 高危

**真实案例**: Truebit协议攻击 (2026年, 损失2600万美元)

**漏洞逻辑**: 
- 合约使用旧版Solidity或部分SafeMath,乘法/加法未检查溢出
- 复杂公式中`uint256`溢出后模`2^256`回绕,天文数字变成极小值
- 整数除法截断进一步放大精度丢失
- 攻击者构造极大输入,使计算结果趋近0

```solidity
// 漏洞示例: Bonding Curve铸造公式
contract VulnerableMint {
    uint256 public totalSupply;
    uint256 public reserve;
    
    // 危险: 旧版Solidity或unchecked环境下
    function calculateCost(uint256 amount) public view returns (uint256) {
        // 分子 = 100 * amount^2 * reserve + 200 * totalSupply * amount * reserve
        // 当amount极大时,分子溢出回绕变成极小值
        uint256 numerator = 100 * amount * amount * reserve 
                          + 200 * totalSupply * amount * reserve;
        uint256 denominator = someFactor;
        
        // 溢出后的小分子 / 分母 = 几乎为0的成本
        return numerator / denominator; // SafeDiv无法防止已溢出的分子
    }
}

// 攻击流程:
// 1. 攻击者选择amount使numerator溢出(如amount > 2^85)
// 2. 正常计算: numerator ≈ 1.15 × 10^77
// 3. 溢出后: numerator ≈ 很小的数(模2^256)
// 4. 最终cost ≈ 0
// 5. 攻击者0成本铸造海量代币,抽干资金池
```

**防御措施**:

```solidity
// 方案1: 使用Solidity 0.8+默认溢出检查
// 方案2: 手动检查中间结果
contract SafeMint {
    function calculateCost(uint256 amount) public view returns (uint256) {
        // 检查乘法是否会溢出
        require(amount <= type(uint256).max / amount, "overflow");
        uint256 amountSquared = amount * amount;
        
        require(amountSquared <= type(uint256).max / reserve / 100, "overflow");
        uint256 term1 = 100 * amountSquared * reserve;
        
        // ... 继续检查每个乘法
    }
}

// 方案3: 使用安全数学库(完整版)
import "@openzeppelin/contracts/utils/math/Math.sol";
// 使用mulDiv防止中间溢出: Math.mulDiv(a, b, c) = a * b / c
```

**检测方法**:
1. 检查Solidity版本,<0.8.0需要完整SafeMath
2. 搜索复杂数学公式(bonding curve/AMM/借贷利率)
3. 验证所有乘法/加法是否有溢出保护
4. 使用极大值(接近`2^128`或`2^256`)进行边界测试
5. 静态分析: `slither --detect divide-before-multiply`

**关键点**: SafeDiv/SafeSub不能防止已经溢出的分子!
